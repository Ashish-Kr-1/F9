================================================================================
  WINDOWS XP WEB CLONE â€” IMPLEMENTATION GUIDE
  Feature-by-Feature Explanation for Web Developers
================================================================================

This document explains â€” in complete, step-by-step detail â€” how a web developer
would implement each of the three core features of our Windows XP web clone:
  1. User Authentication
  2. File Manager (Virtual File System)
  3. Notepad (Text Editor)

The technology stack is:
  Frontend  â€“ React 18 (Vite) with JSX
  Backend   â€“ Node.js / Express 5
  Database  â€“ PostgreSQL (hosted on Supabase)
  Storage   â€“ Google Cloud Storage (with DB fallback)
  Auth      â€“ bcrypt for password hashing, JWT for session tokens

================================================================================
 1. USER AUTHENTICATION
================================================================================

1.1  DATABASE DESIGN
--------------------
We need a `users` table that stores credentials and per-user metadata.

    CREATE TABLE users (
        id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        email         TEXT NOT NULL UNIQUE,
        username      VARCHAR(100) UNIQUE,
        password_hash TEXT NOT NULL,
        storage_quota_bytes BIGINT DEFAULT 10737418240,   -- 10 GB
        storage_used_bytes  BIGINT DEFAULT 0,
        created_at    TIMESTAMPTZ DEFAULT NOW(),
        updated_at    TIMESTAMPTZ DEFAULT NOW(),
        last_login    TIMESTAMPTZ
    );

Key decisions:
  â€¢ UUID primary keys â€” avoids sequential ID guessing.
  â€¢ password_hash â€” we NEVER store the raw password.
  â€¢ storage_quota_bytes â€” allows per-user resource limits.

1.2  BACKEND â€” REGISTRATION  (POST /api/auth/register)
------------------------------------------------------
File: backend/routes/auth.js

Step-by-step flow:
  1. Extract `email`, `password`, and optional `username` from req.body.
  2. Validate that both email and password are present (return 400 otherwise).
  3. Check if the email already exists in the DB:
        SELECT id FROM users WHERE email = $1
     If a row is returned â†’ respond with 409 Conflict.
  4. Derive a default username from the email prefix if none was given.
  5. Hash the password with bcrypt (10 salt rounds):
        const passwordHash = await bcrypt.hash(password, 10);
  6. INSERT the new user row RETURNING id, email, username, created_at.
  7. Immediately after, create a root folder for the user in the `files` table
     so the File Manager has somewhere to start:
        INSERT INTO files (user_id, name, type, parent_id)
        VALUES ($userId, 'C:', 'folder', NULL)
  8. Sign a JWT containing { userId } with a 7-day expiry:
        jwt.sign({ userId }, process.env.JWT_SECRET, { expiresIn: '7d' })
  9. Return { user, token } with status 201.

1.3  BACKEND â€” LOGIN  (POST /api/auth/login)
---------------------------------------------
  1. Extract `email` and `password` from req.body.
  2. Look up the user:
        SELECT * FROM users WHERE email = $1
     No row â†’ 401 "Invalid credentials".
  3. Compare the supplied password against the hash:
        await bcrypt.compare(password, user.password_hash)
     Mismatch â†’ 401.
  4. Sign a JWT and return { user, token } as in registration.
  5. Strip `password_hash` from the returned user object for safety.

1.4  BACKEND â€” GET CURRENT USER  (GET /api/auth/me)
----------------------------------------------------
  â€¢ Protected by the `verifyToken` middleware (see below).
  â€¢ Simply SELECT the user by req.userId and return their profile.

1.5  JWT MIDDLEWARE  (backend/middleware/authMiddleware.js)
----------------------------------------------------------
  â€¢ Extracts the `Authorization: Bearer <token>` header.
  â€¢ Calls jwt.verify(token, JWT_SECRET).
  â€¢ On success, attaches `req.userId = decoded.userId` and calls next().
  â€¢ On failure, returns 401.

This middleware is applied to every protected route using:
    router.get('/protected', verifyToken, handler);

1.6  FRONTEND â€” AuthContext  (frontend/src/context/AuthContext.jsx)
-------------------------------------------------------------------
We use React Context to make user state available app-wide.

  â€¢ Creates an Axios instance `api` with baseURL pointing to our backend.
  â€¢ Provides `login(email, password)` and `register(email, password)` functions
    that call the backend, store the JWT in localStorage, set the Authorization
    header on the Axios instance, and update the `user` state.
  â€¢ Provides `logout()` to clear the token and reset state.
  â€¢ Every component can use `const { user, api } = useAuth()`.

1.7  FRONTEND â€” LoginScreen  (frontend/src/components/LoginScreen/LoginScreen.jsx)
-----------------------------------------------------------------------------------
  â€¢ A Windows XP-themed login form with a user avatar, username input, and
    password input.
  â€¢ On submit, calls either `login()` or `register()` from AuthContext.
  â€¢ Displays error messages inline.
  â€¢ Toggles between "Log In" and "Create Account" views.

1.8  FRONTEND â€” App.jsx Routing
-------------------------------
  â€¢ If `user` is null â†’ show <LoginScreen />.
  â€¢ If `user` is set â†’ show the Desktop + Taskbar (the logged-in XP environment).
  â€¢ This is a simple conditional render, no router library needed.


================================================================================
 2. FILE MANAGER (Virtual File System)
================================================================================

2.1  DATABASE DESIGN
--------------------
We use the `files` table with a self-referential `parent_id` for hierarchy:

    CREATE TABLE files (
        id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        user_id     UUID NOT NULL REFERENCES users(id),
        name        TEXT NOT NULL,
        type        TEXT NOT NULL CHECK (type IN ('file','folder')),
        mime_type   TEXT,
        size_bytes  BIGINT DEFAULT 0,
        storage_key TEXT,            -- GCS object key
        parent_id   UUID REFERENCES files(id),
        is_deleted  BOOLEAN DEFAULT false,
        created_at  TIMESTAMP DEFAULT NOW(),
        updated_at  TIMESTAMP DEFAULT NOW()
    );

And a `file_versions` table for version tracking:

    CREATE TABLE file_versions (
        id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        file_id        UUID NOT NULL REFERENCES files(id),
        version_number INTEGER NOT NULL,
        storage_key    TEXT NOT NULL,
        size_bytes     BIGINT NOT NULL,
        created_at     TIMESTAMP DEFAULT NOW()
    );

Design rationale:
  â€¢ Adjacency list (parent_id) is simpler than materialized path for our use case.
  â€¢ `is_deleted` enables soft-delete / Recycle Bin logic.
  â€¢ `storage_key` maps to a Google Cloud Storage object.

2.2  BACKEND ROUTES  (backend/routes/vfs.js)
--------------------------------------------

GET /api/vfs/root
  â€¢ Queries for the user's root folder (parent_id IS NULL).
  â€¢ If none exists (legacy user), auto-creates one.
  â€¢ Returns { id, name, node_type, parent_id, path, created_at }.

GET /api/vfs/:nodeId/children
  â€¢ SELECT * FROM files WHERE parent_id = $nodeId AND is_deleted = false
  â€¢ Returns an array of child nodes.

POST /api/vfs/create
  â€¢ Body: { name, type, parentId }
  â€¢ Inserts into `files` with the user's ID.
  â€¢ Returns the newly created node.

PATCH /api/vfs/:nodeId/rename
  â€¢ Body: { newName }
  â€¢ UPDATE files SET name = $newName WHERE id = $nodeId AND user_id = $userId.
  â€¢ Returns success message.

DELETE /api/vfs/:nodeId
  â€¢ Soft-delete: UPDATE files SET is_deleted = true.
  â€¢ This preserves the data for potential restore.

2.3  FILE CONTENT ROUTES  (backend/routes/files.js)
---------------------------------------------------

POST /api/files/:nodeId/content
  â€¢ Body: { text }
  â€¢ If GCS is configured (GCS_BUCKET_NAME env var set):
      â€“ Upload text to `bucket.file(gcsKey).save(text)`.
  â€¢ Else: fallback to storing content directly in `file_versions.fallback_content`.
  â€¢ Insert a new row in `file_versions` with incremented version number.
  â€¢ Update `files.storage_key` and `files.size_bytes`.

GET /api/files/:nodeId/content
  â€¢ Look up `files.storage_key`.
  â€¢ If GCS: download from bucket and return text.
  â€¢ If fallback: query latest `file_versions.fallback_content`.
  â€¢ Return { content: "..." }.

2.4  GOOGLE CLOUD STORAGE INTEGRATION
--------------------------------------
  â€¢ We use `@google-cloud/storage` npm package.
  â€¢ On server startup, we try to initialize `new Storage()`.
  â€¢ This requires either GOOGLE_APPLICATION_CREDENTIALS env var pointing to
    a service account JSON file, or running on GCP with default credentials.
  â€¢ If initialization fails, the server still works using DB fallback.
  â€¢ Storage key format: `user_{userId}/file_{nodeId}.txt`

2.5  FRONTEND â€” FileExplorer  (frontend/src/apps/FileExplorer/FileExplorer.jsx)
--------------------------------------------------------------------------------

State management:
  â€¢ rootNode, currentNode â€” track which folder is open.
  â€¢ children â€” array of items in the current folder.
  â€¢ pathStack â€” [{id, name}, ...] breadcrumb trail for proper path display.
  â€¢ view â€” 'details' | 'icons' | 'list' toggle.
  â€¢ isCreating / newItemName / newItemType â€” inline create form.
  â€¢ renamingId / renameValue â€” inline rename editing.

Path display (the fix):
  We do NOT rely on server-computed paths. Instead, we maintain a `pathStack`
  array on the client. When the user navigates into folder "Documents", we push
  { id, name: "Documents" } onto the stack. The address bar shows:
      pathStack.map(p => p.name).join('\\')
  â†’ "C:\\Documents\\Projects"
  This is always correct because it mirrors navigation actions 1:1.

Navigation:
  â€¢ handleOpenNode(folder) â†’ push onto pathStack, fetch children.
  â€¢ handleUp() â†’ pop from pathStack, fetch parent's children.
  â€¢ navigateToBreadcrumb(index) â†’ slice stack and fetch.

Create:
  â€¢ Click "New Folder" or "New File" â†’ shows inline input.
  â€¢ On submit, POST /api/vfs/create â†’ refresh children.

Rename:
  â€¢ Click âœï¸ button â†’ turns the name cell into an input field.
  â€¢ On blur or Enter, PATCH /api/vfs/:nodeId/rename â†’ refresh children.
  â€¢ On Escape â†’ cancel.

Delete:
  â€¢ Click ğŸ—‘ï¸ button â†’ confirm dialog â†’ DELETE /api/vfs/:nodeId.

Opening files:
  â€¢ Double-clicking a file node opens Notepad via the WindowManager:
      openWindow({ appId, title, component: Notepad, componentProps: { fileNode } })
  â€¢ The `componentProps` are passed through WindowContext to the Window component.


================================================================================
 3. NOTEPAD (Text Editor)
================================================================================

3.1  CONCEPT
------------
Notepad is a simple plain-text editor that loads and saves files through the
File Manager's storage API. It can also be opened standalone (with local
download fallback).

3.2  FRONTEND â€” Notepad  (frontend/src/apps/Notepad/Notepad.jsx)
-----------------------------------------------------------------

Props:
  â€¢ fileNode (optional) â€” passed from FileExplorer via WindowManager.
    Contains { id, name, node_type }.

State:
  â€¢ text â€” the editor content.
  â€¢ fileName â€” display name in title.
  â€¢ wordWrap â€” toggle for CSS white-space.
  â€¢ loading â€” true while fetching content from backend.

On mount (useEffect):
  If fileNode is provided, call loadFile():
      const res = await api.get(`/files/${fileNode.id}/content`);
      setText(res.data.content || '');

Save logic:
  If fileNode is provided:
      await api.post(`/files/${fileNode.id}/content`, { text });
  Else (standalone, no file linked):
      Create a Blob, generate an object URL, trigger browser download.

UI structure:
  1. Menu bar â€” File, Edit, Format, View, Help labels.
  2. Toolbar â€” New button, Save button, Word Wrap checkbox.
  3. Textarea â€” the main editing area.
  4. Status bar â€” line count, character count, encoding (UTF-8).

3.3  HOW NOTEPAD CONNECTS TO THE FILE MANAGER
----------------------------------------------
The integration works through these layers:

  FileExplorer â†’ WindowContext â†’ Window â†’ Notepad
                                   â†‘
                            componentProps = { fileNode }

  1. FileExplorer detects a file double-click.
  2. Calls openWindow({ component: Notepad, componentProps: { fileNode } }).
  3. WindowContext stores the window config including componentProps.
  4. Window.jsx renders <WindowComponent windowId={...} {...componentProps} />.
  5. Notepad receives `fileNode` as a prop and fetches its content from the API.

3.4  BACKEND FLOW for NOTEPAD
-----------------------------
  Load:  Notepad â†’ GET /api/files/:nodeId/content
         â†’ Backend reads from GCS (or fallback DB)
         â†’ Returns { content: "hello world" }

  Save:  Notepad â†’ POST /api/files/:nodeId/content  { text: "hello world" }
         â†’ Backend uploads to GCS (or stores in DB fallback)
         â†’ Creates new file_versions row
         â†’ Updates files.storage_key and size_bytes
         â†’ Returns { message: "Content saved", size, version }


================================================================================
 HOW EVERYTHING CONNECTS â€” THE BIG PICTURE
================================================================================

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     HTTP/JSON      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   React App  â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’  â”‚  Express Server  â”‚
  â”‚              â”‚                    â”‚                  â”‚
  â”‚  AuthContext â”€â”¼â”€â”€ /api/auth/*  â”€â”€â†’â”‚  routes/auth.js  â”‚â”€â”€â†’ users table
  â”‚  FileExplorerâ”¼â”€â”€ /api/vfs/*   â”€â”€â†’â”‚  routes/vfs.js   â”‚â”€â”€â†’ files table
  â”‚  Notepad    â”€â”¼â”€â”€ /api/files/* â”€â”€â†’â”‚  routes/files.js â”‚â”€â”€â†’ GCS + file_versions
  â”‚  Clippy     â”€â”¼â”€â”€ /api/clippy  â”€â”€â†’â”‚  routes/clippy.jsâ”‚â”€â”€â†’ FastAPI AI backend
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                            â”‚
                                       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                                       â”‚PostgreSQL â”‚
                                       â”‚(Supabase) â”‚
                                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Security model:
  â€¢ Every /api/vfs/* and /api/files/* route is protected by verifyToken
    middleware.
  â€¢ Every DB query includes user_id in the WHERE clause to enforce multi-tenancy.
  â€¢ Passwords are bcrypt-hashed before storage; JWTs expire after 7 days.

================================================================================
 END OF DOCUMENT
================================================================================
